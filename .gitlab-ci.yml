# Jobs are named [subproject][task].

# Reference: https://github.com/fezu54/flutter-gitlab-ci-example/blob/master/.gitlab-ci.yml

stages:
  - prep
  - test
  - build
  - predeploy
  - deploy

workflow:
  rules:
    - if: ($CI_MERGE_REQUEST_TITLE =~ /WIP:/) || ($CI_MERGE_REQUEST_TITLE =~ /Draft:/)
      when: never
    - if: $CI_MERGE_REQUEST_ID
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_COMMIT_BRANCH == "master"
    - if: $CI_COMMIT_BRANCH == "release"

# Create a job that only runs if neither of the subdirectories have changed. This is so MRs that don't change any of
# those files will still generate a pipeline and comply with "prevent merge unless a pipeline succeeded" rule.

compliance:
  stage: prep
  tags:
    - docker
  script:
    - echo "Running compliance job to enable merge requests."
  rules:
    - changes:
        - client/**/*
        - server/**/*
      when: never
    - if: $CI_MERGE_REQUEST_ID
      when: always

# Choose the pipeline channel (develop/staging/release) by commit branch and store it in PIPELINE_CHANNEL
.pipeline-channel-variable: &pipeline-channel-variable >
  if   [ "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME" == "release" ] || [ "$CI_COMMIT_BRANCH" == "release" ]; then PIPELINE_CHANNEL="release";
  elif [ "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME" == "master"  ] || [ "$CI_COMMIT_BRANCH" == "master"  ]; then PIPELINE_CHANNEL="staging";
  else PIPELINE_CHANNEL="develop"; fi

# Rule for manual jobs on any critical commit.
.manual-commit-rule: &manual-commit-rule
  if: ($CI_COMMIT_BRANCH == "develop" || $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "release")
  when: manual
  allow_failure: true

### Server Jobs

# Rule for automatic pipelines on merge requests with server changes.
.server-merge-request-rule: &server-merge-request-rule
  if: $CI_MERGE_REQUEST_ID
  changes: [server/**/*]

# Rule for automatic pipelines on critical commits with server changes.
.server-commit-rule: &server-commit-rule
  if: ($CI_COMMIT_BRANCH == "develop" || $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "release")
  changes: [server/**/*]

.server-cache: &server-cache
  key:
    files:
      - server/package-lock.json
  paths:
    - server/.npm-cache

.server:
  image: node:16-alpine
  tags:
    - docker
  before_script:
    # server pipeline variables
    - *pipeline-channel-variable
    # move into the server directory
    - cd server
    # install alpine deps (ideally this would happen in a custom dockerfile)
    - apk add --quiet --no-cache openjdk8
    # install the server dependencies
    - npm ci --cache .npm-cache --prefer-offline --log-level error
    # add locally installed bins to the path so we can run firebase-tools
    - PATH="$(npm bin):$PATH"
    # configure the firebase environment
    - firebase use $PIPELINE_CHANNEL
  cache:
    <<: *server-cache
    policy: pull

server:prep:
  stage: prep
  extends:
    - .server
  rules:
    - *server-merge-request-rule
    - *server-commit-rule
    - *manual-commit-rule
  script:
    # before_script will automatically update npm cache
    - echo "Updating server cache."
  cache:
    <<: *server-cache
    policy: pull-push

server:lint:
  stage: test
  extends:
    - .server
  script:
    - npm run lint
  rules:
    - *server-merge-request-rule
    - *server-commit-rule
    - *manual-commit-rule
  dependencies:
    - server:prep
  allow_failure: true

server:test:
  stage: test
  extends:
    - .server
  script:
    # copy GOOGLE_APPLICATION_CREDENTIALS from environment into fastlane target
    - cp "$GOOGLE_APPLICATION_CREDENTIALS" "$(pwd)/gutlogic-dev-firebase-adminsdk.json"
    - npm run test
  rules:
    - *server-merge-request-rule
    - *server-commit-rule
    - *manual-commit-rule
  dependencies:
    - server:prep

server:deploy:
  stage: deploy
  extends:
    - .server
  script:
    - firebase deploy --token $FIREBASE_TOKEN
    - npm run update-data
  rules:
    - *server-commit-rule
    - *manual-commit-rule
  dependencies:
    - server:prep

### Client Jobs

# Rule for client jobs that run on any merge request with client changes.
.client-merge-request-rule: &client-merge-request-rule
  if: $CI_MERGE_REQUEST_ID
  changes: [client/**/*]

# Optional, manual job for any merge request with client changes.
.client-optional-job-rule: &client-optional-job-rule
  if: $CI_MERGE_REQUEST_ID
  changes: [client/**/*]
  when: manual
  allow_failure: true

# Rule for client jobs that run on critical commits with client changes.
.client-commit-rule: &client-commit-rule
  if: ($CI_COMMIT_BRANCH == "develop" || $CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "release")
  changes: [client/**/*]

# Rule for client jobs that run on critical commits with client changes (except develop).
.client-deploy-rule: &client-deploy-rule
  if: ($CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "release")
  changes: [client/**/*]

# Aliases flutter to use fvm if fvm is installed. This is so fvm is used on the mac runner, but not on docker, where it is redundant.
# TODO use a custom docker image with fvm already installed so we can use fvm on both the macos and docker runners
.flutter-fvm: &flutter-fvm >
  if command -v fvm; then
    echo "Using FVM";
    fvm install;
    alias flutter="fvm flutter";
  fi;

.client-cache: &client-cache
  key:
    files:
      - client/pubspec.lock
  paths:
    - client/.pub-cache
    - client/.dart_tool/package_config.json

.client:
  image: cirrusci/flutter:2.5.3
  tags:
    - docker
  before_script:
    - shopt -s expand_aliases
    # client pipeline variables
    - *pipeline-channel-variable
    # move into the client directory
    - cd client
    # configure pub to use a local cache directory
    - export PUB_CACHE=./.pub-cache
    # alias flutter to use fvm
    - *flutter-fvm
    # print the flutter version for logs
    - flutter --version
    # set FLUTTER_FLAVOR based on the pipeline channel
    - if   [ "$PIPELINE_CHANNEL" == "release" ]; then FLUTTER_FLAVOR="production";
      elif [ "$PIPELINE_CHANNEL" == "staging" ]; then FLUTTER_FLAVOR="production";
      else FLUTTER_FLAVOR="development"; fi
    # install dependencies
    - flutter pub get
  cache:
    <<: *client-cache
    policy: pull

client:prep:
  stage: prep
  extends:
    - .client
  script:
    - RELEASE_TAG=$(flutter pub run bin/version)
    # on staging channel append build number so staging tag doesn't conflict with release tag
    - if [ "$PIPELINE_CHANNEL" == "staging" ]; then RELEASE_TAG="v$RELEASE_TAG-b$CI_PIPELINE_ID"; fi
    # write the release tag into the pipeline dotenv file (https://gitlab.com/gitlab-org/gitlab-runner/-/issues/6400)
    - echo "RELEASE_TAG=$RELEASE_TAG" > version.env
    # build autogenerated dart files (models, etc) for artifacts export
    - flutter pub run build_runner build --delete-conflicting-outputs
  rules:
    - *client-merge-request-rule
    - *client-commit-rule
    - *manual-commit-rule
  artifacts:
    reports:
      dotenv: client/version.env
    paths:
      - client/lib/**/*.g.dart
      - client/test/**/*.mocks.dart
      - client/bin/**/*.mocks.dart
    expire_in: 1 day
  cache:
    <<: *client-cache
    policy: pull-push

client:lint:
  stage: test
  extends:
    - .client
  script:
    - flutter analyze --fatal-warnings lib test
    # Delete generated files after analysis but before formatting. They cause the formatter to quit with an error
    # because they are formatter to 80 columns. There's no way to change the source_gen formatting, and no way to
    # exclude the generated files, so we have to delete them (see https://github.com/dart-lang/dart_style/issues/864).
    - find lib test bin -name "*.g.dart" -type f -delete
    - find lib test bin -name "*.mocks.dart" -type f -delete
    - flutter format --line-length 120 --dry-run --set-exit-if-changed lib test
  rules:
    - *client-merge-request-rule
    - *client-commit-rule
    - *manual-commit-rule
  dependencies:
    - client:prep
  allow_failure: true

client:test:
  stage: test
  extends:
    - .client
  script:
    - bash test/generate_coverage_test_file.sh
    - flutter test --coverage
    - lcov --list coverage/lcov.info
    - genhtml coverage/lcov.info -o coverage/html
  artifacts:
    paths:
      - client/coverage
    expire_in: 5 days
  rules:
    - *client-merge-request-rule
    - *client-commit-rule
    - *manual-commit-rule
  dependencies:
    - client:prep

# build:client:apk:
#   stage: build
#   extends:
#     - .client
#   script:
#     - flutter build apk --flavor $FLUTTER_FLAVOR --release --no-codesign
#   rules:
#     - *client-merge-request-rule
#     - *manual-commit-rule

client:build:ios:
  stage: build
  extends:
    - .client
  tags:
    - macos
  script:
    - pod repo update
    - flutter build ios --flavor $FLUTTER_FLAVOR --release --no-codesign
  rules:
    - *client-merge-request-rule
    - *manual-commit-rule
  dependencies:
    - client:prep

client:screenshots:
  stage: predeploy
  extends:
    - .client
  tags:
    - macos
  script:
    # generate screenshots
    - flutter pub run bin/screenshots
    # prep fastlane
    - cd ios/fastlane
    - gem install --user-install bundler
    - bundle install
    # place screenshots into frames
    - bundle exec fastlane frameit download_frames
    - bundle exec fastlane frames
    # remove screenshots without frames so they aren't uploaded to App Store
    - cd screenshots
    - find . -type f ! -name '*_framed.*' -delete
  artifacts:
    paths:
      - client/android/fastlane
      - client/ios/fastlane
    expire_in: 1 day
  rules:
    - *client-deploy-rule
    - *client-optional-job-rule
    - *manual-commit-rule
  dependencies:
    - client:prep

client:tag:
  stage: predeploy
  extends:
    - .client
  tags:
    - macos # required for release tagging
  script:
    # RELEASE_TAG is exported from client:prep
    - echo "Tagging release $RELEASE_TAG ($COMMIT_SHA)"
  release:
    tag_name: "$RELEASE_TAG"
    description: "Release $RELEASE_TAG"
  rules:
    - *client-deploy-rule
    - *manual-commit-rule
  dependencies:
    - client:prep

client:deploy:ios:
  stage: deploy
  extends:
    - .client
  tags:
    - macos
  script:
    # set FASTLANE_CHANNEL to the pipeline channel
    - export FASTLANE_CHANNEL=$PIPELINE_CHANNEL
    # set FLUTTER_APP_VERSION to the pubspec version
    - export FLUTTER_APP_VERSION=$(flutter pub run bin/version)
    # move into ios
    - cd ios
    # copy GOOGLE_APPLICATION_CREDENTIALS from environment into fastlane target
    - cp "$GOOGLE_APPLICATION_CREDENTIALS" "$(pwd)/gc_keys.json"
    # prep fastlane
    - gem install --user-install bundler
    - bundle install
    - bundle exec fastlane run increment_build_number build_number:"$CI_PIPELINE_ID"
    # build:client:ios is skipped on deploy jobs due to issue #29
    - flutter pub run flutter_launcher_icons:main
    - flutter build ios --flavor $FLUTTER_FLAVOR --release --build-number=$CI_PIPELINE_ID --no-codesign
    # execute fastlane (archives and uploads app)
    - bundle exec fastlane $FASTLANE_CHANNEL
  rules:
    - *client-commit-rule
    - *manual-commit-rule
  dependencies:
    - client:prep
    - client:screenshots
